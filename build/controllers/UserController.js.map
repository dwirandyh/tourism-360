{"version":3,"sources":["../../src/controllers/UserController.js"],"names":["UserController","req","res","json","msg","User","findOne","where","id","user","attributes","exclude","status","console","error","message","send","errors","isEmpty","array","body","name","email","password","bcrypt","genSalt","salt","hash","create","payload","jwt","sign","JWT_SECRET","expiresIn","err","token","compare","isMatch","jwtToken"],"mappings":"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","file":"UserController.js","sourcesContent":["import bcrypt from \"bcryptjs\";\r\nimport jwt from \"jsonwebtoken\";\r\nimport { JWT_SECRET } from \"../config\";\r\nimport { validationResult } from \"express-validator/check\";\r\nimport { User } from \"../database/models\";\r\n\r\nclass UserController {\r\n  static async index(req, res) {\r\n    res.json({ msg: \"User List\" });\r\n  }\r\n\r\n  static async detail(req, res) {\r\n    try {\r\n      const user = await User.findOne({\r\n        where: {\r\n          id: req.user.id\r\n        },\r\n        attributes: {\r\n          exclude: [\"password\"]\r\n        }\r\n      });\r\n\r\n      if (!user) {\r\n        return res.status(404).json({ msg: \"User not found\" });\r\n      }\r\n\r\n      res.json(user);\r\n    } catch (err) {\r\n      console.error(err.message);\r\n      res.status(500).send(\"Server error\");\r\n    }\r\n  }\r\n\r\n  static async store(req, res) {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({ errors: errors.array() });\r\n    }\r\n\r\n    let { name, email, password } = req.body;\r\n\r\n    try {\r\n      let user = await User.findOne({\r\n        where: { email: email }\r\n      });\r\n\r\n      if (user) {\r\n        return res\r\n          .status(400)\r\n          .json({ errors: [{ msg: \"User already exissts\" }] });\r\n      }\r\n\r\n      const salt = await bcrypt.genSalt(10);\r\n\r\n      password = await bcrypt.hash(password, salt);\r\n\r\n      user = await User.create({\r\n        name: name,\r\n        email: email,\r\n        password: password\r\n      });\r\n\r\n      const payload = {\r\n        user: {\r\n          id: user.id\r\n        }\r\n      };\r\n\r\n      jwt.sign(payload, JWT_SECRET, { expiresIn: 360000 }, (err, token) => {\r\n        if (err) throw err;\r\n        res.json({ token });\r\n      });\r\n    } catch (err) {\r\n      console.error(err.message);\r\n      res.status(500).send(\"Server error\");\r\n    }\r\n  }\r\n\r\n  static async auth(req, res) {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({ errors: errors.array() });\r\n    }\r\n\r\n    const { email, password } = req.body;\r\n\r\n    try {\r\n      let user = await User.findOne({\r\n        where: { email: email }\r\n      });\r\n\r\n      if (!user) {\r\n        return res\r\n          .status(400)\r\n          .json({ errors: [{ msg: \"Invalid Credentials\" }] });\r\n      }\r\n\r\n      const isMatch = await bcrypt.compare(password, user.password);\r\n\r\n      if (!isMatch) {\r\n        return res\r\n          .status(400)\r\n          .json({ errors: [{ msg: \"Invalid Credentials\" }] });\r\n      }\r\n\r\n      const payload = {\r\n        user: {\r\n          id: user.id\r\n        }\r\n      };\r\n\r\n      User.jwtToken(payload, (err, token) => {\r\n        if (err) throw err;\r\n        return res.json({ token });\r\n      });\r\n    } catch (err) {\r\n      console.error(err.message);\r\n      res.status(500).send(\"Server Error\");\r\n    }\r\n  }\r\n}\r\n\r\nexport default UserController;\r\n"]}